### UNIX 基础知识


#### UNIX 体系结构


从严格意义上说，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。通常将这种软件称为`内核（kernel）`。


内核的接口被称为`系统调用（system call）`。公用函数库构建在系统调用接口之上，应用程序既可使用公用函数库，也可使用系统调用。`shell` 是一个特殊的应用程序，为运行其他应用程序提供了一个接口。

```text
    -----------------------------------------
    |               应用程序                  |
    |    ------------------                 |
    |    |          shell  |                |
    |    |     --------------------         |
    |    |    |      系统调用       |         |
    |    |    |    ------------    |----    |
    |    |----|    |   内核   |     |    |   |
    |    |    |    ------------    |    |   |
    |    |    |--------------------|    |   |
    |    |           公用函数库           |   |
    |    --------------------------------   |
    |                                       |
    ----------------------------------------
```



#### 登录

用户在登录 UNIX 系统时，先键入登录名，然后键入口令。

系统在其口令文件（通常是`etcpasswd` 文件）中查看登录名。口令文件中的登录项由 7 个以冒号分隔的字段组成，依次是：登录名、加密口令、数字用户 ID（205）、数字组 ID（105）、注释字段、起始目录（homesar）以及`shell` 程序（binksh）。

```shell
sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh
```


shell

用户登录后，系统通常先显示一些系统信息，然后用户就可以向 `shell` 程序键入命令。

`shell` 是一个命令行解释器，它读取用户输入，然后执行命令。`shell` 的用户输入通常来自于终端（交互式 `shell`），有时则来自于文件（称为 `shell` 脚本）。

```shell
Bourne shell            binsh
Bourne-again shell      binbash
C shell                 bincsh
Korn shell              binksh 
TENEX C shell           bintcsh
```

`Bourne-again shell` 是 GNU shell，所有 Linux 系统都提供这种 shell。

#### 文件和目录


UNIX 文件系统是目录和文件的一种层次结构，所有东西的起点是称为`根（root）`的目录，这个目录的名称是一个字符“``”。


`目录（directory）`是一个包含目录项的文件。在逻辑上，可以认为每个目录项都包含一个文件名，同时还包含说明该文件属性的信息。

**文件名**

目录中的各个名字称为`文件名（filename）`。只有斜线（``）和空字符这两个字符不能出现在文件名中。斜线用来分隔构成路径名的各文件名，空字符则用来终止一个路径名。

创建新目录时会自动创建了两个文件名：`.`（称为点）和`..`（称为点点）。点指向当前目录，点点指向父目录。在最高层次的根目录中，点点与点相同。

**路径名**

由斜线分隔的一个或多个文件名组成的序列（也可以斜线开头）构成`路径名（pathname）`。

以斜线开头的路径名称为`绝对路径名（absolute pathname）`，否则称为`相对路径名（relative pathname）`。相对路径名指向相对于当前目录的文件。

**工作目录**

每个进程都有一个`工作目录（working directory）`，有时称其为`当前工作目录（current working
directory）`。所有相对路径名都从工作目录开始解释。

**起始目录**

登录时，工作目录设置为`起始目录（home directory）`，该起始目录从口令文件中相应用户的登录项中取得。

#### 输入和输出

**文件描述符**

`文件描述符（file descriptor）`通常是一个小的非负整数，内核用以标识一个特定进程正在访问的文件。当内核打开一个现有文件或创建一个新文件时，它都返回一个文件描述符。

在读、写文件时，可以使用这个文件描述符。

**标准输入、标准输出和标准错误**

按惯例，每当运行一个新程序时，所有的 shell 都为其打开 3 个文件描述符，即`标准输入（standard input）`、`标准输出（standard output）`以及`标准错误（standard error）`。

**不带缓冲的 I/O**

系统函数 `open`、`read`、`write`、`lseek` 以及 `close` 提供了不带缓冲的 I/O。这些函数都使用文件描述符。

头文件`<unistd.h>`是 POSIX 标准的一部分，包含了很多 UNIX 系统服务的函数原型。

```c
#define STDIN_FILENO    0       /* Standard input.  */
#define STDOUT_FILENO   1       /* Standard output.  */
#define STDERR_FILENO   2       /* Standard error output.  */
```

**标准 I/O**

标准 I/O 函数为那些不带缓冲的 I/O 函数提供了一个带缓冲的接口。使用标准 I/O 函数无需担心如何选取最佳的缓冲区大小。



标准 I/O 函数库提供了使我们能够控制该库所使用的缓冲风格的函数。包含`<stdio.h>`头文件中。



#### 程序和进程

`程序（program）`是一个存储在磁盘上某个目录中的可执行文件。内核使用` exec` 函数（7 个`exec` 函数之一），将程序读入内存，并执行程序。

**进程和进程 ID**

程序的执行实例被称为`进程（process）`。某些操作系统用`任务（task）`表示正在被执行的程序。



UNIX 系统确保每个进程都有一个唯一的数字标识符，称为`进程 ID（process ID）`。进程 ID 总是一个非负整数。



**进程控制**

有 3 个用于进程控制的主要函数：`fork`、`exec` 和 `waitpid`。（`exec` 函数有 7 种变体，但经常把它们统称为` exec `函数。）



在子进程中，调用 `execlp` 以执行从标准输入读入的命令。这就用新的程序文件替换了子进程原先执行的程序文件。`fork `和跟随其后的 `exec` 两者的组合就是某些操作系统所称的产生（`spawn`）一个新进程。



子进程调用 `execlp` 执行新程序文件，而父进程希望等待子进程终止，这是通过调用`waitpid` 实现的，其参数指定要等待的进程（即 pid 参数是子进程 ID）。

**线程和线程 ID**

通常，一个进程只有一个`控制线程（thread）` — 某一时刻执行的一组机器指令。

一个进程内的所有线程共享同一地址空间、文件描述符、栈以及与进程相关的属性。因为它们能访问同一存储区，所以各线程在访问共享数据时需要采取同步措施以避免不一致性。



#### 出错处理

当 UNIX 系统函数出错时，通常会返回一个负值，而且整型变量 `errno` 通常被设置为具有特定信息的值。

文件`<errno.h>`中定义了 `errno` 以及可以赋与它的各种常量。这些常量都以字符 `E` 开头。



例如，若 `errno` 等于常量 `EACCES`，表示产生了权限问题（例如，没有足够的权限打开请求文件）。



`POSIX` 和 `ISO C `将 `errno` 定义为一个符号，它扩展成为一个可修改的整形左值（lvalue）。它可以是一个包含出错编号的整数，也可以是一个返回出错编号指针的函数。

```c
extern int errno;
```



在支持线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部`errno`以避免一个线程干扰另一个线程。

例如，Linux 支持多线程存取 `errno`，将其定义为：

```c
extern int *__errno_location(void);
#define errno (*__errno_location())
```



对于 errno 应当注意两条规则:

+ 如果没有出错，其值不会被例程清除。因此，仅当函数的返回值指明出错时，才检验其值。
+ 任何函数都不会将 `errno `值设置为 `0`，而且在`<errno.h>`中定义的所有常量都不为 `0`。



C 标准定义了两个函数，它们用于打印出错信息。

```c
#include <string.h>
char *strerror(int errnum);
	// 返回值：指向消息字符串的指针

void perror(const char *msg);
	// 首先输出由 msg 指向的字符串，然后是一个冒号，一个空格，接着是对应于 errno 值的出错消息
```

**出错恢复**

可将在`<errno.h>`中定义的各种出错分成两类：致命性的和非致命性的。

对于致命性的错误，无法执行恢复动作。最多能做的是在用户屏幕上打印出一条出错消息或者将一条出错消息写入日志文件中，然后退出。

对于非致命性的出错，有时可以较妥善地进行处理。大多数非致命性出错是暂时的（如资源短缺），当系统中的活动较少时，这种出错很可能不会发生。

#### 用户标识

**用户 ID**

口令文件登录项中的`用户 ID（user ID）`是一个数值，它向系统标识各个不同的用户。

系统管理员在确定一个用户的登录名的同时，确定其用户 ID。用户不能更改其用户 ID。通常每个用户有一个唯一的用户 ID。

用户 ID 为 0 的用户为`根用户（root）`或`超级用户（superuser）`。在口令文件中，通常有一个登录项，其登录名为 root，我们称这种用户的特权为超级用户特权。

**组 ID**

口令文件登录项也包括用户的组 ID（group ID），它是一个数值。组 ID 也是由系统管理员在指定用户登录名时分配的。

这种机制允许同组的各个成员之间共享资源（如文件）。



组文件将组名映射为数值的组 ID。组文件通常是`/etc/group`。

**附属组 ID**

除了在口令文件中对一个登录名指定一个组 ID 外，大多数 UNIX 系统版本还允许一个用户属于另外一些组。

POSIX 要求系统至少应支持 8 个附属组，实际上大多数系统至少支持 16 个附属组。



#### 信号

`信号（signal）`用于通知进程发生了某种情况。

例如，若某一进程执行除法操作，其除数为 0，则将名为 `SIGFPE（浮点异常）`的信号发送给该进程。

进程有以下 3 种处理信号的方式。

+ 忽略信号。有些信号表示硬件异常，例如，除以 0 或访问进程地址空间以外的存储单元等，因为这些异常产生的后果不确定，所以不推荐使用这种处理方式。
+ 按系统默认方式处理。对于除数为 0，系统默认方式是终止该进程。
+ 提供一个函数，信号发生时调用该函数，这被称为`捕捉该信号`。通过提供自编的函数，我们就能知道什么时候产生了信号，并按期望的方式处理它。



很多情况都会产生信号。终端键盘上有两种产生信号的方法，分别称为`中断键`（`interrupt key`，通常是 Delete 键或 `Ctrl+C`）和`退出键`（`quit key`，通常是 `Ctrl+\`），它们被用于中断当前运行的进程。



#### 时间值

**日历时间**

该值是自协调世界时（`Coordinated Universal Time，UTC`）1970 年 1 月 1 日00:00:00 这个特定时间以来所经过的秒数累计值（早期的手册称 UTC 为格林尼治标准时间）。这些时间值可用于记录文件最近一次的修改时间等。

系统基本数据类型 `time_t` 用于保存这种时间值。



**进程时间**

也被称为 CPU 时间，用以度量进程使用的中央处理器资源。进程时间以时钟滴答计算。每秒钟曾经取为 50、60 或 100 个时钟滴答。

系统基本数据类型 `clock_t` 保存这种时间值。

当度量一个进程的执行时间时，UNIX 系统为一个进程维护了 3 个进程时间值：

+ 时钟时间
+ 用户 CPU 时间
+ 系统 CPU 时间



时钟时间又称为`墙上时钟时间（wall clock time）`，它是进程运行的时间总量，其值与系统中同时运行的进程数有关。每当在本书中提到时钟时间时，都是在系统中没有其他活动时进行度量的。



用户 CPU 时间是执行用户指令所用的时间量。

系统 CPU 时间是为该进程执行内核程序所经历的时间。例如，每当一个进程执行一个系统服务时，如 read 或 write，在内核内执行该服务所花费的时间就计入该进程的系统 CPU 时间。

用户 CPU 时间和系统 CPU 时间之和常被称为 `CPU时间`。

```shel
$ cd /usr/include
$ time -p grep _POSIX_SOURCE */*.h > /dev/null
real om0.81s
user om0.11s
sys om0.07s
```

#### 系统调用和库函数

所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的 UNIX 实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为`系统调用（system call）`。



UNIX 所使用的技术是为每个系统调用在标准 C 库中设置一个具有同样名字的函数。用户进程用标准 C 调用序列来调用这些函数，然后，函数又用系统所要求的技术调用相应的内核服务。

通用库函数。这些函数可能会调用一个或多个内核的系统调用，但是它们并不是内核的入口点。

应用程序既可以调用系统调用也可以调用库函数。很多库函数则会调用系统调用。

系统调用和库函数之间的另一个差别是：系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能。



​	# end

